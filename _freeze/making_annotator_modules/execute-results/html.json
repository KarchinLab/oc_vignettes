{
  "hash": "6a94ce51ccbd8609a6f84576daf00ab2",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Making an Annotator Module\"\nformat: \n  rst: default\n  html: default\n---\n\n\n\n\n## Annotator Overview\n\n<iframe src=\"https://share.descript.com/embed/TybKsmLT2Rx\" width=\"640\" height=\"360\" frameborder=\"0\" allowfullscreen></iframe>\n\n\n## Annotator Module Build Process\n\nClick on each box in the flowchart below to jump to that part of the build process.\n\n\n\n\n```{mermaid}\nflowchart TD\n  A[Initialize Module] --> B\n  click A \"#initializing-an-annotator-module\"\n  B[Load Annotation\\ninto Database] --> C\n  click B \"#loading-annotations-as-a-sqlite-file\"\n  C[Map Annotations\\nin Python] -->  D\n  click C \"#mapping-our-annotator-file\"\n  D[Customize Output/\\nDisplay] \n```\n\n\n\n\nCreating an annotator module requires the following:\n\n1. Initializing an new annotator skeleton using `oc new annotator <modulename>`\n2. Loading an annotator file into a SQLite database (`<modulename>.sqlite`ss) using `sqlite3`\n3. Mapping the annotator sqlite file in the `<modulename>.py` file\n4. Customizing the output using the `<modulename>.yml` file\n\n### Anatomy of an Annotator Module\n\nThis is a quick review of the basic structure of an annotator module. \n\n\n\n\n```{mermaid}\nflowchart LR\n  A[oc new annotator sift] --> B\n  B[\"sift.py\\n(queries data file)\"]\n  A --> C[\"sift.yml\\n(Maps variants to annotation)\"]\n  A --> D[\"data/sift.sqlite\\n(contains annotation table)\"]\n```\n\n\n\n\n```\n/Users/Shared/open-cravat/modules/annotators/sift\n├── data\n│   └── sift.sqlite               ## contains annotations in sqlite format\n├── sift.md                       ## describes how to use annotator\n├── sift.py                       ## maps annotation columns to variant input\n└── sift.yml                      ## configures output columns\n\n3 directories, 5 files\n```\n\n## Initializing an Annotator Module\n\nBefore we create a new annotator, we need to find where modules are installed on the system. We can do this by using `oc config md`:\n\n\n\n\n```{bash}\noc config md\n```\n\n\n\n\n```\n/Users/Shared/open-cravat/modules\n```\n\nNow we can create our new `sift` module using `oc new annotator`:\n\n\n\n\n```{bash}\n#| eval: false\noc new annotator sift\n```\n\n\n\n\n```\nAnnotator sift_annotator created at /Users/Shared/open-cravat/modules/annotators/sift\n```\n\nIf we take a look at the file structure of our initialized module it looks like this:\n\n\n\n\n```{bash}\ntree  /Users/Shared/open-cravat/modules/annotators/sift/\n```\n\n\n\n\n```\n/Users/Shared/open-cravat/modules/annotators/sift/\n├── data\n│   └── sift.sqlite\n├── sift.md\n├── sift.py\n└── sift.yml\n```\n\nSo now we need to get our annotations into the `sqlite` format, map it in our `annotate()` method, and then customize the display in our `.yml` file.\n\n## Loading Annotations as a SQLite File\n\nOpenCRAVAT requires us to supply our annotations as a SQLite file. `sqlite3` is a database system that allows us to package our annotations in the `.sqlite` format, which makes our annotations accessible to OpenCRAVAT.\n\nSQLite is available on most systems (MacOS/PC/Linux) as the `sqlite3` command. \n\n### Fetching our SQLite Annotations\n\n<iframe src=\"https://share.descript.com/embed/i8O7qSP87s4\" width=\"640\" height=\"360\" frameborder=\"0\" allowfullscreen></iframe>\n\nLet's take a look at an example `.sqlite` file before we load our own. In our annotator's `data/` directory (for example, `/Users/Shared/open-cravat/modules/annotators/sift/data/`), we can fetch an example `.sqlite` file. We'll rename it `sift.sqlite`.\n\n```bash\nwget \"https://github.com/KarchinLab/open-cravat-modules-karchinlab/blob/master/annotators/example/data/example.sqlite?raw=true\" -O sift.sqlite\n\n```\n\n```\n--2024-05-24 07:31:22--  https://github.com/KarchinLab/open-cravat-modules-karchinlab/blob/master/annotators/example/data/example.sqlite\nResolving github.com (github.com)... 140.82.113.4\nConnecting to github.com (github.com)|140.82.113.4|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: unspecified [text/html]\nSaving to: ‘example.sqlite’\n\nexample.sqlite                      [  <=>                                                ] 157.51K   602KB/s    in 0.3s    \n\n2024-05-24 07:31:23 (602 KB/s) - ‘example.sqlite’ saved [161288]\n\n```\n\nNow that we have it in our annotator's `data/` directory, we can query it.\n\n```bash\nsqlite3 sift.sqlite 'select * from sift limit 10;'\n```\n\n```\nchr17|43045681|G|A|1.0|7\nchr17|43045681|G|G|1.0|7\nchr17|43045682|T|A|0.0|7\nchr17|43045682|T|C|0.0|7\nchr17|43045682|T|G|0.0|7\nchr17|43045682|T|T|1.0|7\nchr17|43045683|A|A|1.0|7\nchr17|43045683|A|C|0.0|7\nchr17|43045683|A|G|0.0|7\nchr17|43045683|A|T|0.0|7\n```\n\n### Importing a Comma Separated Value File to SQLite\n\n<iframe src=\"https://share.descript.com/embed/nZAa2LJpI9S\" width=\"640\" height=\"360\" frameborder=\"0\" allowfullscreen></iframe>\n\nNow that we're more familiar with the SQLite format, we can start loading our own version. We'll do this for a CSV (comma separated value) file first.\n\nWe'll first create the `sift.sqlite` file by using `sqlite3`. This will put us into the `sqlite3` prompt interface.\n\n```sql\nsqlite3 sift.sqlite\n```\n\n```\nSQLite version 3.43.2 2023-10-10 13:08:14\nEnter \".help\" for usage hints.\nsqlite>\n```\n\n:::{.callout-note}\n## Interacting with the `sqlite3` prompt\n\nThere are two main ways we can interact with the `sqlite3` interface: **SQL Queries**: \n\n```\nSELECT * from SIFT LIMIT 5;\n```\n\nNote that SQL queries always end with a `;`.\n\nThe other way we can interact with the interface are **dot commands**, such as `.mode` or `.schema` - these do not end with a `;`. These dot commands are are often used to change internal settings for the sqlite database. For example, to set the import format to `.csv`, we can use:\n\n```\n.mode csv\n```\n\nAgain, note that these commands **don't** end with a `;`. You will get errors if you terminate them with `;`.\n\nTo make things easier to distinguish, we'll use all caps for SQL and lowercase for dot commands.\n:::\n\n### Creating Our Table\n\nBefore we load our data in, we need to create our table. This is important because our columns have different data types, and we have to map them to the [SQLite data types](https://www.sqlite.org/draft/datatype3.html):\n\n```sql\nCREATE TABLE \"sift\" ('chrom' TEXT, 'pos' INT, \n                     'ref' TEXT, 'alt' TEXT, \n                     'score' REAL, 'nseq' INT);\nCREATE INDEX main_index on sift (chrom, pos, ref, alt);\n```\n\nNote that `score` (the SIFT score) has a `REAL` data type.\n\nNow that the table is created, we can load our `sift.csv` file. We need to change the mode to `csv`. \n\n```sql\n.mode csv\n```\n\nNow we can import our data using the `.import` dot command. Because our `sift.csv` has a header row, we need to skip it, so we use the `--skip 1` argument. \n\n```sql\n.import --skip 1 sift.csv sift\n```\n\nWe can check that we loaded in our data correctly by using the `.schema` command and a `SELECT *` query:\n\n```sql\n.schema\n```\n```\nCREATE TABLE sift (chrom text, pos int, ref text, alt text, score real, nseq int);\nCREATE INDEX main_index on sift (chrom, pos, ref, alt);\n```\n\ncha\n\n```sql\n.mode box\nSELECT * FROM sift LIMIT 5;\n```\n```\n┌───────┬──────────┬─────┬─────┬───────┬──────┐\n│ chrom │   pos    │ ref │ alt │ score │ nseq │\n├───────┼──────────┼─────┼─────┼───────┼──────┤\n│ chr17 │ 43045681 │ G   │ A   │ 1.0   │ 7    │\n│ chr17 │ 43045681 │ G   │ G   │ 1.0   │ 7    │\n│ chr17 │ 43045682 │ T   │ A   │ 0.0   │ 7    │\n│ chr17 │ 43045682 │ T   │ C   │ 0.0   │ 7    │\n│ chr17 │ 43045682 │ T   │ G   │ 0.0   │ 7    │\n└───────┴──────────┴─────┴─────┴───────┴──────┘\n```\n\n\n\nWhen we're done, we can use `.exit` to exit our session and save our `.sqlite` file.\n\n```sql\n.exit\n```\n\nWe can double check our `.sqlite` file has our information by using `sqlite3` to execute a query on the command line:\n\n\n```sql\nsqlite3 sift.sqlite 'select * from sift limit 5;'\n```\n\n\n:::{.callout-note}\n## Loading VCF Files as Annotations\n\nLet's try loading in an RNA Editing VCF file into a `.sqlite` file.\n\nThe first thing that we should notice is that there are multiple rows we need to skip to load our VCF data in. There are 4 lines of metadata + 1 header row that we need to skip to load our data in correctly.\n\n```bash\ntedladeras$ head GRCh38.RNAediting.vcf \n```\n\n```\n##fileformat=VCFv4.2\n##reference=GRCh38\n##source=Rediportal\n##INFO=<ID=RNAEDIT,Type=String,Description=\"A known or predicted RNA-editing site\">\n#CHROM  POS     ID      REF     ALT     QUAL    FILTER  INFO\nchr1    10187   .       A       G       .       .       RNAEDIT=RADAR\nchr1    10193   .       A       G       .       .       RNAEDIT=RADAR\nchr1    10211   .       A       G       .       .       RNAEDIT=RADAR\nchr1    10217   .       A       G       .       .       RNAEDIT=RADAR\nchr1    10223   .       A       G       .       .       RNAEDIT=RADAR\n```\n\nAgain, we create our database:\n\n```\nsqlite3 vcf.sqlite\n```\n\nThen we can define our table:\n\n```sql\ncreate table \"vcf\" (\"chrom\" TEXT, \"pos\" INT, \"id\" TEXT, \n                    \"ref\" TEXT, \"alt\" TEXT, \"qual\" INT, \n                    \"filter\" TEXT, \"info\" TEXT);\n```\n\nAnd then we can load our VCF file. Note that we need to skip 5 rows (VCF file metadata and the header row) to load our data in.\n\n```sql\n.mode tabs\n.import --skip 5 GRCh38.RNAediting.vcf vcf\n```\n\nThen we can check that we loaded the data correctly:\n\n```sql\n.mode box\nselect * from vcf limit 10;\n```\n\nFinally, now that we're satisfied, we can `.exit`:\n\n```sql\n.exit\n```\n\n:::\n\n\n\n\n\n## Mapping Our Annotator File\n\n<iframe src=\"https://share.descript.com/embed/rrjQ71QQRHY\" width=\"640\" height=\"360\" frameborder=\"0\" allowfullscreen></iframe>\n\nNow that our data is loaded into our `.sqlite` file, we need to set up our mapping. If we look in `sift.py`, we'll see there are stubs for three methods: `setup()`, `annotate()`, and `cleanup()`:\n\n\n\n\n```{mermaid}\nflowchart LR\n  A[sift_annotator.py] --method-->B[\"setup()\"]\n  A --method-->C[\"annotate()\"]\n  A --method-->D[\"cleanup()\"]\n```\n\n\n\n\nThis is what the `.py` file looks like: \n\n```bash\ncat /Users/Shared/open-cravat/modules/annotators/sift/sift.py\n```\n\n```\nimport sys\nfrom cravat import BaseAnnotator\nfrom cravat import InvalidData\nimport sqlite3\nimport os\n\nclass CravatAnnotator(BaseAnnotator):\n\n    def setup(self): \n        \"\"\"\n        Set up data sources. \n        Cravat will automatically make a connection to \n        data/example_annotator.sqlite using the sqlite3 python module. The \n        sqlite3.Connection object is stored as self.dbconn, and the \n        sqlite3.Cursor object is stored as self.cursor.\n        \"\"\"\n        pass\n    \n    def annotate(self, input_data, secondary_data=None):\n        \"\"\"\n        The annotator parent class will call annotate for each line of the \n        input file. It takes one positional argument, input_data, and one\n        keyword argument, secondary_data.\n        \n        input_data is a dictionary containing the data from the current input \n        line. The keys depend on what what file is used as the input, which can \n        be changed in the module_name.yml file. \n        Variant level includes the following keys: \n            ('uid', 'chrom', 'pos', 'ref_base', 'alt_base')\n        Variant level crx files expand the key set to include:\n            ('hugo', 'transcript','so','all_mappings')\n        Gene level files include\n            ('hugo', 'num_variants', 'so', 'all_so')\n        \n        secondary_data is used to allow an annotator to access the output of\n        other annotators. It is described in more detail in the CRAVAT \n        documentation.\n        \n        annotate should return a dictionary with keys matching the column names\n        defined in example_annotator.yml. Extra column names will be ignored, \n        and absent column names will be filled with None. Check your output\n        carefully to ensure that your data is ending up where you intend.\n        \"\"\"\n        out = {}\n        out['placeholder_annotation'] = 'placeholder value'\n        return out\n    \n    def cleanup(self):\n        \"\"\"\n        cleanup is called after every input line has been processed. Use it to\n        close database connections and file handlers. Automatically opened\n        database connections are also automatically closed.\n        \"\"\"\n        pass\n        \nif __name__ == '__main__':\n    annotator = CravatAnnotator(sys.argv)\n    annotator.run()\n```\n\nWe will focus on the `annotate()` method first.\n\n### `annotate()` Method\n\nOur `annotate()` method is where we map our annotations in our `.sqlite` file to an input called `input_data`. `input_data` essentially is a single row of our genomic file to annotate represented as a dictionary. \n\nThis is what our `input_data` list looks like:\n\n\n\n\n```{mermaid}\nerDiagram\n    input_data{\n      string chrom\n      int pos\n      string ref_base\n      string alt_base\n    }\n```\n\n\n\n\nIn order to annotate our file, we need to map each relevant element of `input_data` to a column in our `.sqlite` file.\n\n::::{.columns}\n:::{.column}\n![Mapping between `input_data` and our `sift` table](images/mapping.jpg)\n:::\n:::{.column}\n```python\nchrom = input_data[\"chrom\"]\npos = input_data[\"pos\"]\nquery = (f'select score, nseq from sift' \\\n          'where chrom=\"{chrom}\"'\\\n          'and pos=\"{pos}\"')\nself.cursor.execute(query)\nresult = self.cursor.fetchone()\n```\n:::\n::::\n\nThe first thing we do is we extract `chrom` and `pos` from our list:\n\n```python\nchrom = input_data[\"chrom\"]\npos = input_data[\"pos\"]\n```\n\nLet's look at our query next. \n\n```python\nquery = (f'select score, nseq from sift' \\\n          'where chrom=\"{chrom}\"'\\\n          'and pos=\"{pos}\"')\n```\n\nNote that we are querying our table, so the table's column is on the left size, and the input_data field is on the left. We are using variable substitution in our query to match the value to `chrom` in our table. In other words, our query works like this:\n\n```\nwhere chrom =\"{chrom}\"\n      ^^^^.     ^^^^\n      sift      input_data\n      table\n```\nFinally, we execute our query by using the `execute()` method that was inherited in our class definition.\n\n```python\nself.cursor.execute(query)\nresult = self.cursor.fetchone()\n```\n\nThe last bit calculates a new column, called `prediction` based on the actual SIFT score. We call everthing below \n\n```python\n    if result is not None:\n        score = result[0]\n        num_seq = result[1]\n        if score <= 0.05:\n            prediction = 'Damaging'\n        else:\n            prediction = 'Tolerated'\n```\n\nFinally, we return our annotations as a dictionary. If there was no result, we return `None`:\n\n```python\n        return {\n            'score': score,\n            'seq_count': num_seq,\n            'prediction': prediction,\n        }\n    else:\n        return None\n```\n\nOur final `annotate()` method looks like this:\n\n```python\ndef annotate(self, input_data, secondary_data=None):\n    chrom = input_data['chrom']\n    pos = input_data['pos']\n    ref_base = input_data['ref_base']\n    alt_base = input_data['alt_base']\n    query = f'select score, nseq from sift where chrom=\"{chrom}\" and pos={pos} and ref=\"{ref_base}\" and alt=\"{alt_base}\";'\n    self.cursor.execute(query)\n    result = self.cursor.fetchone()\n    if result is not None:\n        score = result[0]\n        num_seq = result[1]\n        if score <= 0.05:\n            prediction = 'Damaging'\n        else:\n            prediction = 'Tolerated'\n        return {\n            'score': score,\n            'seq_count': num_seq,\n            'prediction': prediction,\n        }\n    else:\n        return None\n```\n\n## Configure `sift_annotator.yml`\n\nNow that our `annotate()` method is filled in, we need to configure how our annotations will be displayed. \n\n\n\n\n```{bash}\n#| eval: false\ncat /Users/Shared/open-cravat/modules/annotators/sift_annotator/sift_annotator.yml\n```\n\n\n\n\n```\n# 'title' is the name of the module that will be displayed to the user\ntitle: Annotator Template\n\n# 'version' is the version of the annotator. It is primarily used when \n# publishing a module, but is required for all modules.\nversion: 0.0.1\n\n# 'type' is the type of module described by this .yml file. In this case it is\n# 'annotator'\ntype: annotator\n\n# 'level' is 'variant' or 'gene'\nlevel: variant\n\n# output_columns has the columns that will be included in the output file.\n# The columns are defined in a list. Each column has three required keys:\n# name, title, and type.\noutput_columns:\n  # name is the internal name and is the key used to identify the column in the\n  # dictionary returned by the annotate method of annotator_name.py\n- name: placeholder_annotation\n  # title is the display name of this column, similar to the title of the module.\n  # It can be changed without affecting the functionality of CRAVAT\n  title: Placeholder Annotation\n  # type is the data type of the value. It is primarily used when storing the \n  # results in a database. It may be one of string, int, or float.\n  type: string\n\n# description is a short description of what the annotator does. Try to limit it\n# to around 80 characters.\ndescription: Template annotator. If you see this description in production, someone is wrong.\n\n# developer is you!\ndeveloper:\n  name: ''\n  organization: ''\n  email: ''\n  website: ''\n  citation: ''\n```\n\nAfter filling it out and cleaning it up, your `sift_annotator.yml` should look like this:\n\n```\ntitle: Sift Annotator\nversion: 0.0.1\ntype: annotator\nlevel: variant\n\noutput_columns:\n- name: prediction\n  title: Prediction\n  type: string\n- name: score\n  title: Score\n  type: float\n- name: seq_count\n  title: Seqs at Position\n  type: int\n\ndescription: Annotates variants with sift scores and categories\n\n[....]\n```\n\n\n\n## Test It Out!\n\nNow that we're finished with building our annotator module, it's time to test it. Try it out with the GUI.\n\n## What You Learned\n\nYou learned the basic annotator module development process, including:\n\n1. Initializing an new annotator skeleton using `oc new annotator <modulename>`\n2. Loading an annotator file into a SQLite database (`<modulename>.sqlite`ss) using `sqlite3`\n3. Mapping the annotator sqlite file in the `<modulename>.py` file\n4. Customizing the output using the `<modulename>.yml` file\n\n",
    "supporting": [
      "making_annotator_modules_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}